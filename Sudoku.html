<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KHO Game — Canvas Sudoku</title>
  <meta name="description" content="KHO Game: 고품질 캔버스 스도쿠. 난이도, 힌트, 메모(펜슬), 자동 후보, 무르기/다시하기, 타이머, 검증·중복 하이라이트." />
  <style>
    :root{
      --bg:#0f1115; --panel:#151925; --text:#d7e1ff; --muted:#8aa0c2; --brand:#66a3ff; --accent:#89f7fe;
      --grid:#101827; --cell:#141a2a; --cell2:#0f1524; --hl:#263249; --sel:#314368; --conflict:#ff6b6b; --fixed:#93c5fd; --note:#8aa0c2;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(160deg,#0b0d12,#0f1115 40%,#0b1020);color:var(--text);
      font:15px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,"Apple SD Gothic Neo","Malgun Gothic",sans-serif}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:18px clamp(16px,4vw,28px);
      background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,0));border-bottom:1px solid rgba(255,255,255,.06);
      position:sticky;top:0;z-index:10;backdrop-filter:blur(6px)}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:36px;height:36px;border-radius:10px;background:radial-gradient(120% 120% at 20% 20%,var(--accent),var(--brand) 60%,#2e5bff 100%);
      box-shadow:0 10px 30px rgba(102,163,255,.35), inset 0 0 24px rgba(255,255,255,.35)}
    .title{font-weight:700;letter-spacing:.2px}
    .subtitle{color:var(--muted);font-size:12px}
    main{max-width:1100px;margin:20px auto;padding:0 clamp(12px,3vw,24px)}
    .grid{display:grid;grid-template-columns: minmax(320px, 640px) 1fr; gap:18px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}

    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);
      border-radius:18px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.4)}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.06)}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;padding:12px 14px;border-top:1px solid rgba(255,255,255,.06)}
    button{background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.05));border:1px solid rgba(255,255,255,.12);color:var(--text);
      padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700;transition:transform .06s ease,border-color .2s ease,background .2s ease}
    button:hover{transform:translateY(-1px);border-color:rgba(102,163,255,.6)}
    .primary{background:linear-gradient(180deg,rgba(102,163,255,.35),rgba(102,163,255,.18));border-color:rgba(102,163,255,.55)}
    select{background:#1a2030;color:var(--text);border:1px solid rgba(255,255,255,.2);border-radius:10px;padding:10px}
    label{display:flex;align-items:center;gap:6px}

    #board{width:100%;aspect-ratio:1/1;display:block;background:var(--grid)}

    .side{padding:16px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px}
    .badge{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 10px;min-width:120px;text-align:center;font-weight:700}
    .label{font-size:12px;color:var(--muted)}
    .moves{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px;height:320px;overflow:auto;font-variant-numeric:tabular-nums}
    .kho{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <div class="title">KHO Game — Canvas Sudoku</div>
        <div class="subtitle">서비스사: <strong>KHO</strong> · 고품질 캔버스 스도쿠</div>
      </div>
    </div>
    <button class="primary" onclick="location.href='/'">메인으로</button>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <div class="topbar">
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
            <div class="badge"><span class="label">타이머</span><span id="timer">00:00</span></div>
            <div class="badge"><span class="label">실수</span><span id="mistakes">0</span></div>
            <div class="badge"><span class="label">상태</span><span id="status">일시정지</span></div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <label><input type="checkbox" id="autoNotes" checked/>자동 후보</label>
            <label><input type="checkbox" id="highlight" checked/>중복 하이라이트</label>
            <select id="difficulty" title="난이도 변경 시 새 게임">
              <option value="easy">쉬움</option>
              <option value="medium" selected>보통</option>
              <option value="hard">어려움</option>
              <option value="expert">익스퍼트</option>
            </select>
            <button class="primary" id="newBtn">새 게임</button>
          </div>
        </div>
        <canvas id="board" width="800" height="800" aria-label="Sudoku board"></canvas>
        <div class="toolbar">
          <button id="pauseBtn">시작</button>
          <button id="hintBtn">힌트</button>
          <button id="checkBtn">검증</button>
          <button id="eraseBtn">지우기</button>
          <button id="noteBtn">메모 모드: 끔 (N)</button>
          <button id="undoBtn">무르기</button>
          <button id="redoBtn">다시하기</button>
        </div>
      </section>

      <aside class="card side">
        <div class="row"><div class="label">선택 셀</div><div id="selInfo">-</div></div>
        <div class="row"><div class="label">후보</div><div id="candInfo">-</div></div>
        <div class="row"><div class="label">채워진 칸</div><div id="fillInfo">0 / 81</div></div>
        <div class="row"><div class="label">난이도</div><div id="diffInfo">보통</div></div>
        <div class="moves" id="log"></div>
        <div class="kho">© KHO · Canvas Sudoku</div>
      </aside>
    </div>
  </main>

<script>
(() => {
  "use strict";
  // ===== Canvas setup =====
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let size = 800, cell; let running=false; let last=0; let secs=0; let timerId=null;

  function fit(){
    const cssW = canvas.clientWidth || canvas.parentElement.clientWidth;
    const w = Math.round(cssW * dpr); canvas.width = w; canvas.height = w; size = w; cell = size/9; draw();
  }
  new ResizeObserver(fit).observe(canvas);

  // ===== State =====
  const S = {
    givens: new Array(81).fill(0), // 0 empty else 1-9
    board: new Array(81).fill(0),  // working board
    notes: Array.from({length:81}, ()=> new Set()),
    solved: new Array(81).fill(0),
    selected: -1,
    mistakes: 0,
    noteMode: false,
    autoNotes: true,
    highlight: true,
    difficulty: 'medium',
    history: [],
    redo: [],
  };

  // ===== Utils =====
  const rc = (i)=>[Math.floor(i/9), i%9];
  const idx = (r,c)=> r*9+c;
  const boxId = (r,c)=> Math.floor(r/3)*3 + Math.floor(c/3);
  function inRange(v){ return v>=1 && v<=9; }
  function cloneArr(a){ return a.slice(); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function countFilled(a){ let n=0; for(const v of a) if(v) n++; return n; }

  function row(r,arr){ const out=[]; for(let c=0;c<9;c++) out.push(arr[idx(r,c)]); return out; }
  function col(c,arr){ const out=[]; for(let r=0;r<9;r++) out.push(arr[idx(r,c)]); return out; }
  function box(b,arr){ const r0=Math.floor(b/3)*3, c0=(b%3)*3; const out=[]; for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++) out.push(arr[idx(r0+dr,c0+dc)]); return out; }
  function validArray(a){ const seen=new Set(); for(const v of a){ if(v===0) continue; if(seen.has(v)) return false; seen.add(v);} return true; }
  function validBoard(arr){ for(let i=0;i<9;i++){ if(!validArray(row(i,arr))) return false; if(!validArray(col(i,arr))) return false; if(!validArray(box(i,arr))) return false; } return true; }

  function candidatesAt(i, arr){
    if(arr[i]) return new Set();
    const [r,c]=rc(i); const used = new Set([...row(r,arr), ...col(c,arr), ...box(boxId(r,c),arr)]);
    const cands = new Set(); for(let d=1; d<=9; d++) if(!used.has(d)) cands.add(d); return cands;
  }

  // ===== Solver (MRV + backtracking) =====
  function solve(grid){
    const a = grid.slice();
    function choose(){ let min=10, k=-1, cand=null; for(let i=0;i<81;i++){ if(a[i]===0){ const c=candidatesAt(i,a); const n=c.size; if(n<min){ min=n; k=i; cand=c; if(n===1) break; } } } return [k,cand]; }
    function backtrack(){
      const [k,cand]=choose(); if(k===-1) return true; if(cand.size===0) return false; for(const d of cand){ a[k]=d; if(backtrack()) return true; a[k]=0; } return false;
    }
    const ok = backtrack(); return ok ? a : null;
  }
  // Count solutions up to limit
  function countSolutions(grid, limit=2){
    let count=0; const a=grid.slice();
    function choose(){ let min=10, k=-1, cand=null; for(let i=0;i<81;i++){ if(a[i]===0){ const c=candidatesAt(i,a); const n=c.size; if(n<min){ min=n; k=i; cand=c; if(n===1) break; } } } return [k,cand]; }
    function dfs(){ if(count>=limit) return; const [k,cand]=choose(); if(k===-1){ count++; return; } if(cand.size===0) return; for(const d of cand){ a[k]=d; dfs(); if(count>=limit) return; a[k]=0; } }
    dfs(); return count;
  }

  // Generate full solved board
  function generateSolved(){
    const a=new Array(81).fill(0); const order = Array.from({length:81}, (_,i)=>i);
    function fill(pos=0){ if(pos===81) return true; const i=order[pos]; const cands=shuffle([...candidatesAt(i,a)]); for(const d of cands){ a[i]=d; if(fill(pos+1)) return true; a[i]=0; } return false; }
    // Seed first row with a Latin pattern then shuffle digits to speed up
    const base=[1,2,3,4,5,6,7,8,9]; const perm=shuffle(base.slice()); for(let c=0;c<9;c++) a[idx(0,c)]=perm[c];
    fill(9); return a;
  }

  // Carve puzzle with uniqueness
  function makePuzzle(solved, diff){
    const a = solved.slice(); const holes = Array.from({length:81}, (_,i)=>i); shuffle(holes);
    const target = {easy:[40,45], medium:[32,36], hard:[26,30], expert:[22,26]}[diff] || [32,36];
    const minClues = target[0], maxClues = target[1];
    let removed=0;
    for(const i of holes){ const keep = a[i]; a[i]=0; if(countSolutions(a,2)!==1){ a[i]=keep; } else { removed++; if(81-removed<=maxClues) break; } }
    // Ensure at least minClues left (if not, revert some removals)
    const clues = 81-removed; if(clues<minClues){
      for(let i=0;i<81 && 81-removed<minClues;i++){ if(a[i]===0){ a[i]=solved[i]; removed--; } }
    }
    return a;
  }

  // ===== Rendering =====
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background cells
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const x=c*cell, y=r*cell; const i=idx(r,c);
        const even = ((r/3|0)+(c/3|0))%2===0; ctx.fillStyle = even? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.05)';
        ctx.fillRect(x,y,cell,cell);
      }
    }
    // highlight row/col/box for selection
    if(S.selected!==-1){ const [sr,sc]=rc(S.selected);
      ctx.fillStyle='rgba(102,163,255,0.12)';
      ctx.fillRect(0, sr*cell, size, cell); ctx.fillRect(sc*cell, 0, cell, size);
      const r0=(sr/3|0)*3, c0=(sc/3|0)*3; ctx.fillRect(c0*cell, r0*cell, cell*3, cell*3);
    }

    // numbers & notes
    for(let i=0;i<81;i++){
      const [r,c]=rc(i); const x=c*cell, y=r*cell; const v=S.board[i]; const g=S.givens[i];
      if(v){
        const wrong = S.highlight && v!==S.solved[i] && g===0;
        ctx.fillStyle = g? 'rgba(147,197,253,0.98)' : wrong? 'rgba(255,107,107,0.95)' : '#e8eeff';
        ctx.font = (cell*0.6)+'px ui-sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(String(v), x+cell/2, y+cell/2+1);
      } else if(S.notes[i].size){
        ctx.fillStyle='rgba(138,160,194,0.9)'; ctx.font=(cell*0.18)+'px ui-sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        let k=0; for(let nr=0; nr<3; nr++){ for(let nc=0; nc<3; nc++){ k++; const d=nr*3+nc+1; if(S.notes[i].has(d)) ctx.fillText(String(d), x+cell*(nc+0.5)/3, y+cell*(nr+0.5)/3+0.5); }}
      }
    }

    // grid lines
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=Math.max(1, size/800);
    for(let k=0;k<=9;k++){ const p=Math.round(k*cell)+0.5; ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(size,p); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,size); ctx.stroke(); }
    // bold lines
    ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=Math.max(2, size/400);
    for(let k=0;k<=9;k+=3){ const p=Math.round(k*cell)+0.5; ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(size,p); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,size); ctx.stroke(); }

    // selection border
    if(S.selected!==-1){ const [r,c]=rc(S.selected); const x=c*cell, y=r*cell; ctx.strokeStyle='rgba(102,163,255,0.9)'; ctx.lineWidth=Math.max(2, size/500); ctx.strokeRect(x+1,y+1,cell-2,cell-2); }
  }

  // ===== Actions =====
  function pushHistory(){ S.history.push({board:S.board.slice(), notes:S.notes.map(s=>new Set(s)), mistakes:S.mistakes}); if(S.history.length>400) S.history.shift(); S.redo.length=0; }
  function undo(){ const s=S.history.pop(); if(!s) return; S.redo.push({board:S.board.slice(), notes:S.notes.map(s=>new Set(s)), mistakes:S.mistakes}); S.board=s.board; S.notes=s.notes; S.mistakes=s.mistakes; draw(); updateSide(); }
  function redo(){ const s=S.redo.pop(); if(!s) return; S.history.push({board:S.board.slice(), notes:S.notes.map(s=>new Set(s)), mistakes:S.mistakes}); S.board=s.board; S.notes=s.notes; S.mistakes=s.mistakes; draw(); updateSide(); }

  function setValue(i, d){ if(S.givens[i]) return; pushHistory(); if(S.noteMode){ if(S.notes[i].has(d)) S.notes[i].delete(d); else S.notes[i].add(d); }
    else { S.board[i]=d; S.notes[i].clear(); if(S.autoNotes) refreshAutoNotes(); if(S.highlight && d!==S.solved[i]) S.mistakes++; }
    draw(); updateSide(); checkSolved(); }
  function eraseValue(){ if(S.selected===-1||S.givens[S.selected]) return; pushHistory(); S.board[S.selected]=0; S.notes[S.selected].clear(); if(S.autoNotes) refreshAutoNotes(); draw(); updateSide(); }

  function checkSolved(){ if(S.board.every((v,i)=>v===S.solved[i])){ statusEl.textContent='완료!'; pause(true); log('🎉 퍼즐 완료'); } }

  function refreshAutoNotes(){ for(let i=0;i<81;i++){ if(S.givens[i]||S.board[i]){ S.notes[i].clear(); continue; } const c=candidatesAt(i,S.board); S.notes[i]=c; } updateSide(); }

  // ===== Game flow =====
  const timerEl=document.getElementById('timer'); const mistakeEl=document.getElementById('mistakes'); const statusEl=document.getElementById('status');
  const autoNotesEl=document.getElementById('autoNotes'); const highlightEl=document.getElementById('highlight'); const diffSel=document.getElementById('difficulty');
  const logEl=document.getElementById('log');
  function log(msg){ const t=document.createElement('div'); t.textContent=msg; logEl.appendChild(t); logEl.scrollTop=logEl.scrollHeight; }

  function start(){ if(running) return; running=true; statusEl.textContent='플레이 중'; if(!timerId) timerId=setInterval(()=>{ secs++; timerEl.textContent = formatTime(secs); }, 1000); }
  function pause(done=false){ running=false; if(!done) statusEl.textContent='일시정지'; }
  function resetNew(){ secs=0; timerEl.textContent='00:00'; S.mistakes=0; mistakeEl.textContent='0'; S.history.length=0; S.redo.length=0; }

  function newGame(){ pause(); resetNew(); const diff=diffSel.value; S.difficulty=diff; document.getElementById('diffInfo').textContent=diffLabel(diff);
    const solved=generateSolved(); const puzzle=makePuzzle(solved, diff); S.solved=solved; S.givens=puzzle.map(v=>v?1:0); S.board=puzzle.slice(); S.notes=Array.from({length:81},()=>new Set()); if(S.autoNotes) refreshAutoNotes(); draw(); updateSide(); statusEl.textContent='일시정지'; log('🧩 새 퍼즐 시작: '+diffLabel(diff)); }

  function diffLabel(d){ return d==='easy'?'쉬움': d==='medium'?'보통': d==='hard'?'어려움':'익스퍼트'; }
  function formatTime(s){ const m=(s/60|0); const ss=(s%60); return String(m).padStart(2,'0')+':'+String(ss).padStart(2,'0'); }

  // ===== Input =====
  function getCellFromEvent(ev){ const r=canvas.getBoundingClientRect(); const x=(ev.clientX-r.left)*(canvas.width/r.width); const y=(ev.clientY-r.top)*(canvas.height/r.height); const c=(x/cell)|0, rr=(y/cell)|0; if(rr<0||rr>8||c<0||c>8) return -1; return idx(rr,c); }
  canvas.addEventListener('mousedown', (e)=>{ const k=getCellFromEvent(e); if(k===-1) return; S.selected=k; draw(); updateSide(); start(); });
  canvas.addEventListener('mousemove', (e)=>{ /* no drag for now */});
  canvas.addEventListener('mouseup', (e)=>{});

  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ togglePause(); return; }
    if(S.selected!==-1){ if(e.key>='1' && e.key<='9'){ setValue(S.selected, parseInt(e.key,10)); }
      if(e.key==='Backspace' || e.key==='Delete' || e.key==='0'){ eraseValue(); }
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
        const [r,c]=rc(S.selected); let nr=r, nc=c; if(e.key==='ArrowUp') nr=Math.max(0,r-1); if(e.key==='ArrowDown') nr=Math.min(8,r+1); if(e.key==='ArrowLeft') nc=Math.max(0,c-1); if(e.key==='ArrowRight') nc=Math.min(8,c+1); S.selected=idx(nr,nc); draw(); updateSide(); }
    }
    if(e.key==='n' || e.key==='N'){ toggleNoteMode(); }
  });

  // Buttons
  document.getElementById('newBtn').addEventListener('click', ()=>{ newGame(); });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ togglePause(); });
  document.getElementById('hintBtn').addEventListener('click', ()=>{ hint(); });
  document.getElementById('checkBtn').addEventListener('click', ()=>{ validateBoard(); });
  document.getElementById('eraseBtn').addEventListener('click', ()=>{ eraseValue(); });
  document.getElementById('noteBtn').addEventListener('click', ()=>{ toggleNoteMode(true); });
  document.getElementById('undoBtn').addEventListener('click', ()=>{ undo(); });
  document.getElementById('redoBtn').addEventListener('click', ()=>{ redo(); });
  autoNotesEl.addEventListener('change', ()=>{ S.autoNotes=autoNotesEl.checked; if(S.autoNotes) refreshAutoNotes(); draw(); });
  highlightEl.addEventListener('change', ()=>{ S.highlight=highlightEl.checked; draw(); });
  diffSel.addEventListener('change', ()=>{ newGame(); });

  function togglePause(){ running=!running; statusEl.textContent=running?'플레이 중':'일시정지'; if(running && !timerId) timerId=setInterval(()=>{ secs++; timerEl.textContent = formatTime(secs); }, 1000); }
  function toggleNoteMode(forceToggle=false){ if(forceToggle) S.noteMode=!S.noteMode; const btn=document.getElementById('noteBtn'); btn.textContent = `메모 모드: ${S.noteMode?'켬':'끔'} (N)`; draw(); }

  function hint(){
    // If selected and empty, fill correct; else fill any single-candidate cell
    pushHistory();
    if(S.selected!==-1 && !S.board[S.selected]){ S.board[S.selected]=S.solved[S.selected]; S.notes[S.selected].clear(); }
    else{
      let filled=false; for(let i=0;i<81;i++){ if(!S.board[i]){ const c=candidatesAt(i,S.board); if(c.size===1){ const v=[...c][0]; S.board[i]=v; filled=true; break; } } }
      if(!filled){ // fallback: fill random empty with solved value
        const empties = S.board.map((v,i)=>v?null:i).filter(v=>v!==null); if(empties.length){ const k=empties[(Math.random()*empties.length)|0]; S.board[k]=S.solved[k]; }
      }
    }
    if(S.autoNotes) refreshAutoNotes(); draw(); updateSide(); checkSolved(); log('✨ 힌트 사용');
  }

  function validateBoard(){
    // highlight duplicates by flashing status
    const bad = [];
    for(let r=0;r<9;r++){ const a=row(r,S.board); for(let d=1; d<=9; d++){ if(a.filter(v=>v===d).length>1) bad.push('행 '+(r+1)); }}
    for(let c=0;c<9;c++){ const a=col(c,S.board); for(let d=1; d<=9; d++){ if(a.filter(v=>v===d).length>1) bad.push('열 '+(c+1)); }}
    for(let b=0;b<9;b++){ const a=box(b,S.board); for(let d=1; d<=9; d++){ if(a.filter(v=>v===d).length>1) bad.push('박스 '+(b+1)); }}
    if(bad.length){ statusEl.textContent='중복: '+[...new Set(bad)].join(', '); }
    else { statusEl.textContent='유효함'; }
  }

  function updateSide(){ document.getElementById('mistakes').textContent=String(S.mistakes); document.getElementById('fillInfo').textContent=`${countFilled(S.board)} / 81`;
    if(S.selected!==-1){ const [r,c]=rc(S.selected); document.getElementById('selInfo').textContent=`R${r+1}C${c+1}`; const cands=candidatesAt(S.selected,S.board); document.getElementById('candInfo').textContent=[...cands].sort().join(' ')||'-'; } else { document.getElementById('selInfo').textContent='-'; document.getElementById('candInfo').textContent='-'; }
  }

  // ===== Init =====
  function init(){ fit(); newGame(); toggleNoteMode(false); }
  init();

  // ===== Self tests (console) =====
  function assert(name, cond){ if(cond){ console.log('✅', name);} else { console.error('❌', name);} }
  (function selfTests(){
    // 1) solver solves known easy puzzle
    const p = [
      5,3,0, 0,7,0, 0,0,0,
      6,0,0, 1,9,5, 0,0,0,
      0,9,8, 0,0,0, 0,6,0,

      8,0,0, 0,6,0, 0,0,3,
      4,0,0, 8,0,3, 0,0,1,
      7,0,0, 0,2,0, 0,0,6,

      0,6,0, 0,0,0, 2,8,0,
      0,0,0, 4,1,9, 0,0,5,
      0,0,0, 0,8,0, 0,7,9];
    const s = solve(p); assert('솔버 결과 존재', !!s); assert('솔버 유효 보드', s && validBoard(s));

    // 2) generator validity
    const sol = generateSolved(); assert('생성 솔루션 유효', validBoard(sol));

    // 3) uniqueness check returns >=1 for a solvable board
    const cnt = countSolutions(p, 2); assert('해결 가능성 체크', cnt>=1);

    // 4) candidatesAt sanity
    const i0 = idx(0,2); const cset = candidatesAt(i0, p); assert('후보 포함 1~9 중 일부', cset.size>0 && cset.size<=9);
  })();
})();
</script>
</body>
</html>
