<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Sky Runner · Mini Game</title>
  <style>
    :root {
      --bg1: #0f1023;
      --bg2: #1f2251;
      --panel: rgba(255,255,255,0.06);
      --panel-strong: rgba(255,255,255,0.12);
      --text: #e9ecff;
      --muted: #b8c0ff;
      --accent: #7aa2ff;
      --accent-2: #b388ff;
      --danger: #ff6b6b;
      --ok: #6bff95;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    [data-theme="light"] {
      --bg1: #ecf2ff;
      --bg2: #cfe0ff;
      --panel: rgba(0,0,0,0.06);
      --panel-strong: rgba(0,0,0,0.12);
      --text: #151826;
      --muted: #2b3155;
      --accent: #3b6cff;
      --accent-2: #7f56d9;
      --danger: #e5484d;
      --ok: #2bb673;
      --shadow: 0 10px 30px rgba(0,0,0,0.12);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      color: var(--text);
      background: radial-gradient(1200px 600px at 20% -10%, var(--bg2), transparent 70%),
                  radial-gradient(1000px 800px at 100% 0%, var(--accent-2), transparent 60%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }

    .topbar {
      position: relative; z-index: 1000;
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 14px 16px; border-radius: 16px;
      background: var(--panel);
      backdrop-filter: blur(10px) saturate(130%);
      border: 1px solid var(--panel-strong);
      box-shadow: var(--shadow);
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 28px; height: 28px; border-radius: 8px;
      background: conic-gradient(from 210deg, var(--accent), var(--accent-2));
      box-shadow: inset 0 0 12px rgba(255,255,255,0.35), 0 0 20px rgba(122,162,255,0.35);
    }
    h1 { font-size: 18px; margin: 0; letter-spacing: 0.2px; }

    .controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }

    .btn {
      appearance: none; border: 1px solid var(--panel-strong);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.06));
      color: var(--text); padding: 10px 12px; border-radius: 12px; cursor: pointer;
      font-weight: 600; letter-spacing: .2px; box-shadow: var(--shadow);
      transition: transform .08s ease, filter .2s ease, border-color .2s ease;
    }
    .btn:hover { filter: brightness(1.07); }
    .btn:active { transform: translateY(1px) scale(0.98); }
    .btn.primary { border-color: transparent; background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: white; }
    .btn.ghost { background: transparent; }

    .toggle { display: inline-flex; align-items: center; gap: 8px; }
    .toggle input { display: none; }

    .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; opacity: .9; background: var(--panel); border: 1px solid var(--panel-strong); }

    /* Custom select (난이도) */
    .select-custom{position:relative}
    .select-custom .select-trigger{position:relative}
    .select-menu{position:absolute; top:calc(100% + 6px); left:0; min-width:140px; padding:6px; margin:0; list-style:none; border-radius:12px; border:1px solid var(--panel-strong); background:var(--panel); box-shadow: var(--shadow); display:none; z-index:2000; overflow: visible;}
    .select-menu.open{display:block}
    .select-menu li{padding:8px 10px; border-radius:8px; cursor:pointer; color:var(--text)}
    .select-menu li[aria-selected="true"]{outline:2px solid var(--accent);}
    .select-menu li:hover{background:rgba(255,255,255,0.08)}

    .game-card {
      position: relative; margin-top: 16px; border-radius: 20px; overflow: hidden;
      background: var(--panel); border: 1px solid var(--panel-strong); box-shadow: var(--shadow);
    }

    .hud {
      position: absolute; inset: 12px 12px auto auto; display: flex; gap: 10px; z-index: 3;
    }
    .hud .pill { background: rgba(0,0,0,0.25); border: 1px solid var(--panel-strong); backdrop-filter: blur(8px);
      padding: 6px 10px; border-radius: 999px; font-weight: 700; font-variant-numeric: tabular-nums; }

    .canvas-wrap { position: relative; width: 100%; aspect-ratio: 16 / 9; }
    canvas { display: block; width: 100%; height: 100%; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; z-index: 4;
      background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.25));
      backdrop-filter: blur(6px);
    }
    .panel {
      text-align: center; max-width: 680px; padding: 20px; border-radius: 20px;
      background: var(--panel); border: 1px solid var(--panel-strong); box-shadow: var(--shadow);
    }
    .panel h2 { margin: 6px 0 8px; font-size: 28px; }
    .panel p { margin: 6px 0; color: var(--muted); }

    .grid-keys { margin: 12px auto; display: grid; grid-template-columns: repeat(3, minmax(80px, 1fr)); gap: 8px; max-width: 340px; }
    .key { padding: 8px 10px; border-radius: 12px; border: 1px solid var(--panel-strong); background: rgba(255,255,255,0.05); }

    .jump-btn {
      position: absolute; right: 16px; bottom: 16px; z-index: 3; font-size: 16px;
      padding: 12px 16px; border-radius: 16px; border: 1px solid var(--panel-strong);
      background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: white; box-shadow: var(--shadow);
      display: none;
    }
    @media (hover: none) and (pointer: coarse) { .jump-btn { display: inline-block; } }

    .toast { position: absolute; left: 50%; transform: translateX(-50%); bottom: 18px; z-index: 5; opacity: 0; transition: opacity .3s ease; }
    .toast .badge { background: rgba(0,0,0,0.35); }

    footer { text-align: center; margin: 12px 0 4px; opacity: .8; font-size: 13px; }

    dialog { border: none; padding: 0; border-radius: 16px; color: var(--text); background: var(--panel); border: 1px solid var(--panel-strong); }
    dialog::backdrop { background: rgba(0,0,0,0.5); }
    .dialog-inner { padding: 18px; max-width: 560px; }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar" role="banner">
      <div class="brand" aria-label="게임 제목">
        <div class="logo" aria-hidden="true"></div>
        <h1>Sky Runner</h1>
      </div>
      <div class="controls">
        <!-- 커스텀 난이도 셀렉트 -->
        <div class="select-custom" id="diffBox">
          <button class="btn ghost select-trigger" id="diffBtn" aria-haspopup="listbox" aria-expanded="false" aria-controls="diffMenu">
            <span id="diffLabel">보통</span>
          </button>
          <ul class="select-menu" id="diffMenu" role="listbox" tabindex="-1" aria-label="난이도 설정">
            <li role="option" data-value="easy"   aria-selected="false">쉬움</li>
            <li role="option" data-value="normal" aria-selected="true">보통</li>
            <li role="option" data-value="hard"   aria-selected="false">어려움</li>
            <li role="option" data-value="insane" aria-selected="false">매우 어려움</li>
          </ul>
        </div>

        <button class="btn ghost" id="helpBtn" aria-haspopup="dialog" aria-controls="helpDialog">도움말</button>
        <button class="btn ghost" id="pauseBtn" aria-pressed="false">일시정지(P)</button>
        <button class="btn ghost" id="soundBtn" aria-pressed="true">사운드 On</button>
        <label class="btn toggle" title="테마 전환">
          <input type="checkbox" id="themeToggle" />
          <span>라이트</span>
        </label>
        <button class="btn primary" id="resetBestBtn">최고점 초기화</button>
      </div>
    </div>

    <section class="game-card" aria-label="게임 영역">
      <div class="hud" aria-live="polite">
        <div class="pill">점수: <span id="score">0</span></div>
        <div class="pill">최고점: <span id="best">0</span></div>
        <div class="pill" id="speedPill">속도: 1.0x</div>
      </div>

      <div class="canvas-wrap">
        <canvas id="game" role="img" aria-label="하늘을 달리며 장애물을 피하는 러너 게임"></canvas>
        <div class="overlay" id="overlay">
          <div class="panel">
            <h2>Tap · Click · Space 로 점프!</h2>
            <p>장애물을 피해 가능한 오래 달려보세요. 시간이 지날수록 속도가 증가합니다.</p>
            <div class="grid-keys" aria-hidden="true">
              <div class="key">스페이스</div>
              <div class="key">↑ / W</div>
              <div class="key">터치/클릭</div>
            </div>
            <button id="startBtn" class="btn primary" style="min-width:160px">게임 시작</button>
            <p style="margin-top:10px; font-size:13px; opacity:.8">모바일/PC 지원 · 로컬 저장소에 최고점/난이도 기록</p>
          </div>
        </div>
        <div class="toast" id="toast"><span class="badge">일시정지</span></div>
        <button class="jump-btn" id="jumpBtn">JUMP</button>
      </div>
    </section>

    <footer>© <span id="year"></span> Sky Runner. Published by KHO.</footer>
  </div>

  <dialog id="helpDialog" aria-labelledby="helpTitle">
    <div class="dialog-inner">
      <h3 id="helpTitle" style="margin:0 0 6px">플레이 방법</h3>
      <ul style="margin: 6px 0 10px; line-height: 1.7">
        <li><strong>점프:</strong> 스페이스 / ↑ / W / 화면 터치</li>
        <li><strong>빠른 하강:</strong> ↓ / S (난이도 쉬움·보통에서만)</li>
        <li><strong>일시정지:</strong> P 키 또는 상단 버튼</li>
        <li><strong>사운드:</strong> 상단 버튼으로 On/Off</li>
        <li><strong>목표:</strong> 장애물을 뛰어넘어 <em>최대한 오래</em> 달리세요. 속도는 점점 빨라집니다.</li>
        <li><strong>팁:</strong> 착지 직전에 다시 점프하면 더 멀리 뛰어요! (콤보 보너스)</li>
      </ul>
      <div style="display:flex; gap:8px; justify-content:flex-end">
        <button class="btn ghost" id="closeHelp">닫기</button>
      </div>
    </div>
  </dialog>

  <script>
  // DOMContentLoaded로 안전하게 초기화 (요소가 준비되기 전에 접근하는 문제 방지)
  document.addEventListener('DOMContentLoaded', () => {
    const $ = (sel) => document.querySelector(sel);

    // ==== Element refs ====
    const canvas = $('#game');
    const ctx = canvas?.getContext('2d');
    const scoreEl = $('#score');
    const bestEl = $('#best');
    const speedPill = $('#speedPill');
    const overlay = $('#overlay');
    const startBtn = $('#startBtn');
    const jumpBtn = $('#jumpBtn');
    const helpBtn = $('#helpBtn');
    const helpDialog = $('#helpDialog');
    const closeHelp = $('#closeHelp');
    const pauseBtn = $('#pauseBtn');
    const soundBtn = $('#soundBtn');
    const themeToggle = $('#themeToggle');
    const resetBestBtn = $('#resetBestBtn');
    const toast = $('#toast');
    const yearEl = $('#year');
    const diffBox = $('#diffBox');
    const diffBtn = $('#diffBtn');
    const diffMenu = $('#diffMenu');
    const diffLabel = $('#diffLabel');
    let helpPausedByDialog = false;

    // 필수 요소 체크 (테스트 겸 안전장치)
    const required = { canvas, ctx, scoreEl, bestEl, speedPill, overlay, startBtn, helpBtn, pauseBtn, soundBtn, themeToggle, resetBestBtn, diffBox, diffBtn, diffMenu, diffLabel };
    for (const [k,v] of Object.entries(required)) {
      if (!v) console.warn(`[SkyRunner] Missing element: ${k}`);
    }

    // 연도 표시
    if (yearEl) yearEl.textContent = String(new Date().getFullYear());

    // ==== Theme ====
    const savedTheme = localStorage.getItem('sr_theme');
    if (savedTheme === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
      if (themeToggle) themeToggle.checked = true;
    }
    themeToggle?.addEventListener('change', () => {
      const mode = themeToggle.checked ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('sr_theme', mode);
    });

    // ==== Audio ====
    let audioCtx = null; let soundOn = true;
    const ensureAudio = () => { if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {} } };
    function playBeep(type='jump') {
      if (!soundOn) return; ensureAudio(); if (!audioCtx) return;
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type = (type === 'hit') ? 'square' : 'sine';
      const now = audioCtx.currentTime;
      const freq = type === 'jump' ? 760 : type === 'score' ? 1040 : 220;
      o.frequency.setValueAtTime(freq, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(type==='hit'?0.6:0.3, now+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, now + (type==='hit'?0.4:0.18));
      o.connect(g).connect(audioCtx.destination);
      o.start(now); o.stop(now + (type==='hit'?0.42:0.2));
    }

    soundBtn?.addEventListener('click', () => {
      soundOn = !soundOn; soundBtn.textContent = soundOn ? '사운드 On' : '사운드 Off';
      soundBtn.setAttribute('aria-pressed', String(soundOn));
      if (soundOn) { ensureAudio(); playBeep('score'); }
    });

    // ==== Canvas size ====
    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    const resize = () => {
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * DPR);
      canvas.height = Math.floor(rect.height * DPR);
    };
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // ==== Difficulty config ====
    const DIFF = {
      // 더 여유 있는 간격, 점프는 짧아져서 연속 점프가 쉬움
      easy:   { speed: 3.8, gravity: 1650, jumpV: 700, spawnEvery: 1400, minSpawn: 800, minGap: 420 },
      // 기본 난이도: 여유 간격 + 짧은 체공
      normal: { speed: 4.6, gravity: 1800, jumpV: 660, spawnEvery: 1200, minSpawn: 650, minGap: 360 },
      // 어려움: 속도↑ 간격↓
      hard:   { speed: 5.4, gravity: 1950, jumpV: 640, spawnEvery: 950,  minSpawn: 520, minGap: 300 },
      // 매우 어려움: 빠른 템포, 최소 간격 축소
      insane: { speed: 6.0, gravity: 2050, jumpV: 630, spawnEvery: 850,  minSpawn: 420, minGap: 260 },
    };

    // ==== Game State ====
    let currentDiff = localStorage.getItem('sr_diff') || 'normal';
    const G = {
      running: false,
      paused: false,
      over: false,
      t: 0,
      speed: DIFF[currentDiff].speed,
      speedMul: 1,
      gravity: DIFF[currentDiff].gravity,
      jumpV: DIFF[currentDiff].jumpV,
      combo: 0,
      score: 0,
      best: Number(localStorage.getItem('sr_best') || 0),
      lastSpawn: 0,
      spawnEvery: DIFF[currentDiff].spawnEvery, // ms
      minSpawn: DIFF[currentDiff].minSpawn,
      minGap: DIFF[currentDiff].minGap,
      worldH: () => canvas.height,
      worldW: () => canvas.width,
      groundY: () => Math.floor(canvas.height * 0.82),
    };

    if (bestEl) bestEl.textContent = G.best.toString();

    // ==== Entities ====
    const player = { w: 56, h: 64, x: 140, y: 0, vy: 0, onGround: false, color: '#ffffff', glow: 'rgba(122,162,255,0.65)' };
    const obstacles = [];
    const particles = [];
    const clouds = Array.from({ length: 7 }, () => ({ x: Math.random(), y: Math.random()*0.45 + 0.05, s: Math.random()*0.6 + 0.4 }));

    const rnd = (a,b) => Math.random()*(b-a)+a;

    function reset() {
      G.score = 0; G.speedMul = 1; G.t = 0; G.over = false; G.combo = 0; G.lastSpawn = 0; G.spawnEvery = DIFF[currentDiff].spawnEvery;
      player.y = G.groundY() - player.h; player.vy = 0; player.onGround = true;
      obstacles.length = 0; particles.length = 0;
      if (speedPill) speedPill.textContent = `속도: ${G.speedMul.toFixed(1)}x`;
      if (scoreEl) scoreEl.textContent = '0';
    }

    function applyDifficulty(name) {
      currentDiff = name; localStorage.setItem('sr_diff', name);
      const d = DIFF[name];
      G.speed = d.speed; G.gravity = d.gravity; G.jumpV = d.jumpV; G.spawnEvery = d.spawnEvery; G.minSpawn = d.minSpawn; G.minGap = d.minGap;
      showToast(`난이도: ${name}`);
    }

    // ==== UI: Custom select ====
    function setDiffUI(name){
      if (!diffLabel || !diffMenu) return;
      diffLabel.textContent = name==='easy'?'쉬움':name==='normal'?'보통':name==='hard'?'어려움':'매우 어려움';
      [...diffMenu.children].forEach(li=>li.setAttribute('aria-selected', String(li.dataset.value===name)));
    }
    function openMenu(){ diffMenu?.classList.add('open'); diffBtn?.setAttribute('aria-expanded','true'); diffMenu?.focus(); }
    function closeMenu(){ diffMenu?.classList.remove('open'); diffBtn?.setAttribute('aria-expanded','false'); }

    // 변경: 난이도 변경 시 즉시 재시작, 도움말 버튼 클릭 시 일시정지 + 다이얼로그 오픈
    function changeDifficultyAndRestart(v) {
      applyDifficulty(v);
      setDiffUI(v);
      if (overlay) overlay.style.display = 'none';
      startGame();
    }
    function openHelpDialog(){
      if (G.running && !G.paused && !G.over) {
        pauseToggle();
        helpPausedByDialog = true;
      } else {
        helpPausedByDialog = false;
      }
      helpDialog?.showModal();
    }

    diffBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); const open = diffMenu?.classList.contains('open'); open?closeMenu():openMenu(); });
    diffMenu?.addEventListener('click', (e)=>{ const li = e.target.closest('li'); if(!li) return; const v = li.dataset.value; closeMenu(); changeDifficultyAndRestart(v); });
    document.addEventListener('click', (e)=>{ if(diffBox && !diffBox.contains(e.target)) closeMenu(); });
    diffMenu?.addEventListener('keydown', (e)=>{
      const items=[...diffMenu.children];
      let idx=items.findIndex(li=>li.getAttribute('aria-selected')==='true');
      if(e.key==='Escape'){ closeMenu(); diffBtn?.focus(); return; }
      if(e.key==='ArrowDown' || e.key==='ArrowUp'){
        e.preventDefault();
        idx = e.key==='ArrowDown'? Math.min(idx+1, items.length-1) : Math.max(idx-1, 0);
        items.forEach((li,i)=> li.setAttribute('aria-selected', String(i===idx)) );
        return;
      }
      if(e.key==='Enter' || e.key===' '){
        e.preventDefault();
        const v = items[idx]?.dataset.value; if(!v) return;
        closeMenu();
        changeDifficultyAndRestart(v);
      }
    });
    setDiffUI(currentDiff);

    // ==== Game actions (HOISTED to avoid ReferenceError) ====
    function showToast(text) { if (!toast) return; toast.innerHTML = `<span class="badge">${text}</span>`; toast.style.opacity = '1'; clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.style.opacity = '0', 1100); }
    function emitDust(count=6) { for (let i=0;i<count;i++) particles.push({ x: player.x + player.w*0.5 + rnd(-10,10), y: player.y + player.h, vx: rnd(-90, 90), vy: rnd(-280, -80), life: rnd(0.25, 0.55), t: 0, c: 'rgba(255,255,255,0.8)' }); }
    function boom() { for (let i=0;i<34;i++) particles.push({ x: player.x+player.w/2, y: player.y+player.h/2, vx: rnd(-460,460), vy: rnd(-460,460), life: rnd(0.28,0.7), t: 0, c: 'rgba(255,107,107,0.95)'}); }
    function jump() { if (!G.running || G.paused || G.over) return; if (player.onGround) { ensureAudio(); playBeep('jump'); player.vy = -G.jumpV * (1 + Math.min(G.combo*0.06, 0.24)); player.onGround = false; emitDust(8); } }
    function pauseToggle() { if (!G.running || G.over) return; G.paused = !G.paused; pauseBtn?.setAttribute('aria-pressed', String(G.paused)); if (pauseBtn) pauseBtn.textContent = G.paused ? '재개(P)' : '일시정지(P)'; showToast(G.paused ? '일시정지' : '재개'); }

    // 빠른 하강: 쉬움/보통에서만 허용
    function fastDrop() {
      if (!G.running || G.paused || G.over) return;
      if (!(currentDiff === 'easy' || currentDiff === 'normal')) return;
      if (player.onGround) return; // 공중에서만 의미 있음
      player.y = G.groundY() - player.h;
      player.vy = 0;
      player.onGround = true;
      G.combo = 0; // 보너스 악용 방지
      emitDust(4);
    }

    // ===== Rendering helpers =====
    function rectsIntersect(x1,y1,w1,h1,x2,y2,w2,h2) { return (x1<x2+w2 && x1+w1>x2 && y1<y2+h2 && y1+h1>y2); }
    function drawCloud(x,y,r) {
      ctx.fillStyle = document.documentElement.dataset.theme==='light' ? 'rgba(255,255,255,0.85)' : 'rgba(255,255,255,0.65)';
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.arc(x+r*0.8, y+2, r*0.7, 0, Math.PI*2); ctx.arc(x-r*0.8, y+4, r*0.6, 0, Math.PI*2); ctx.fill();
    }
    function drawObstacle(ob) {
      const grad = ctx.createLinearGradient(ob.x, ob.y, ob.x, ob.y+ob.h);
      grad.addColorStop(0, document.documentElement.dataset.theme==='light' ? '#4b5bd6' : '#6b79ff');
      grad.addColorStop(1, document.documentElement.dataset.theme==='light' ? '#33408f' : '#3a4296');
      ctx.fillStyle = grad; roundRect(ob.x, ob.y, ob.w, ob.h, 6*DPR); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.25)'; roundRect(ob.x+2*DPR, ob.y+2*DPR, ob.w-4*DPR, 8*DPR, 4*DPR); ctx.fill();
    }
    function drawPlayer() {
      const pulse = 0.5 + Math.sin(performance.now()/120) * 0.5; ctx.save();
      ctx.shadowBlur = 18*DPR; ctx.shadowColor = 'rgba(122,162,255,0.65)';
      const grad = ctx.createLinearGradient(player.x, player.y, player.x, player.y+player.h);
      grad.addColorStop(0, document.documentElement.dataset.theme==='light' ? '#ffffff' : '#eaf0ff');
      grad.addColorStop(1, document.documentElement.dataset.theme==='light' ? '#cdd6ff' : '#a9baff');
      ctx.fillStyle = grad; roundRect(player.x, player.y, player.w, player.h, 10*DPR); ctx.fill(); ctx.shadowBlur = 0;
      ctx.fillStyle = '#2b2e52'; ctx.beginPath(); ctx.arc(player.x + player.w*0.72, player.y + player.h*0.35, 4*DPR, 0, Math.PI*2); ctx.fill();
      ctx.fillRect(player.x + player.w*0.24, player.y + player.h*0.65, player.w*0.52, 4*DPR);
      if (!player.onGround) { ctx.globalAlpha = 0.2 + 0.2*pulse; ctx.fillStyle = 'rgba(122,162,255,0.65)'; ctx.beginPath(); ctx.ellipse(player.x + player.w*0.5, player.y + player.h + 18*DPR, 20*DPR, 8*DPR, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
      ctx.restore();
    }
    function roundRect(x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath();
    }
    function draw() {
      const W = canvas.width, H = canvas.height; ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, document.documentElement.dataset.theme==='light' ? '#cfe0ff' : '#0a0e2a');
      g.addColorStop(1, document.documentElement.dataset.theme==='light' ? '#a7bfff' : '#111847');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(W*0.82, H*0.18, Math.max(24, W*0.025), 0, Math.PI*2);
      ctx.fillStyle = document.documentElement.dataset.theme==='light' ? '#fff7cc' : '#b7c2ff'; ctx.fill(); ctx.globalAlpha = 1;
      ctx.save(); ctx.globalAlpha = 0.75; for (const cl of clouds) drawCloud(W*cl.x, H*cl.y, 60*cl.s*DPR); ctx.restore();
      const gy = G.groundY();
      ctx.fillStyle = document.documentElement.dataset.theme==='light' ? '#2f3a73' : '#0a0d28';
      ctx.fillRect(0, gy, W, H-gy);
      ctx.fillStyle = document.documentElement.dataset.theme==='light' ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.25)';
      ctx.fillRect(0, gy-2*DPR, W, 2*DPR);
      for (const p of particles) { ctx.save(); ctx.globalAlpha = 1 - (p.t / p.life); ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(1, 3*DPR*(1-p.t/p.life)), 0, Math.PI*2); ctx.fill(); ctx.restore(); }
      for (const ob of obstacles) drawObstacle(ob);
      drawPlayer();
    }

    // 접근성: 모션 감소 선호 시 약간 완화
    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) { G.gravity *= 0.9; G.jumpV *= 0.9; }

    // ==== Loop (define BEFORE startGame usage) ====
    let lastTime = performance.now(); let rafId = 0;
    function rafStart() { cancelAnimationFrame(rafId); lastTime = performance.now(); rafId = requestAnimationFrame(loop); }
    function loop(now) {
      const dt = Math.min((now - lastTime)/1000, 1/24); // clamp
      lastTime = now;
      if (G.running && !G.paused && !G.over) update(dt);
      draw();
      rafId = requestAnimationFrame(loop);
    }
    function update(dt) {
      G.t += dt * 1000;
      G.speedMul = 1 + Math.min(G.t / 30000, 1.0);
      if (speedPill) speedPill.textContent = `속도: ${G.speedMul.toFixed(1)}x`;
      if (G.spawnEvery > G.minSpawn) G.spawnEvery -= dt * 10; // gradually quicker spawns
      for (const cl of clouds) { cl.x -= dt * 0.02 * (0.5 + cl.s); if (cl.x < -0.1) cl.x = 1.1; }
      player.vy += G.gravity * dt; player.y += player.vy * dt;
      if (player.y + player.h >= G.groundY()) {
        if (!player.onGround && player.vy > 0) { G.combo = Math.min(G.combo + 1, 10); if (G.combo > 1) { G.score += (G.combo-1); playBeep('score'); } emitDust(6); }
        player.y = G.groundY() - player.h; player.vy = 0; player.onGround = true;
      } else { player.onGround = false; }
      if (G.t - G.lastSpawn > G.spawnEvery) { trySpawnObstacle(); }
      const speed = (G.speed * G.speedMul) * (canvas.width/1280) * 60 * dt;
      for (const ob of obstacles) ob.x -= speed;
      while (obstacles.length && obstacles[0].x + obstacles[0].w < -60) { obstacles.shift(); G.score += 1; if (scoreEl) scoreEl.textContent = G.score.toString(); playBeep('score'); }
      for (let i=particles.length-1; i>=0; i--) { const p = particles[i]; p.t += dt; p.x += p.vx * dt; p.y += p.vy * dt; p.vy += G.gravity*0.8*dt; if (p.t > p.life) particles.splice(i,1); }
      for (const ob of obstacles) {
        if (rectsIntersect(player.x, player.y, player.w, player.h, ob.x, ob.y, ob.w, ob.h)) {
          if (!ob.hit) { ob.hit = true; G.over = true; playBeep('hit'); boom(); G.best = Math.max(G.best, G.score); localStorage.setItem('sr_best', String(G.best)); if (bestEl) bestEl.textContent = G.best.toString(); setTimeout(() => showGameOver(), 30); }
        }
      }
    }
    function trySpawnObstacle() {
      const last = obstacles[obstacles.length - 1];
      const gap = (G.minGap || 320) * (canvas.width/1280);
      if (last && last.x > canvas.width - gap) {
        // 아직 이전 장애물이 너무 가까움 → 스폰 보류
        return false;
      }
      spawnObstacle();
      G.lastSpawn = G.t;
      return true;
    }
    function spawnObstacle() {
      // 높이/너비를 소폭 줄여 이동 공간 확보
      const h = rnd(34, 66) * (canvas.height/720);
      const w = rnd(28, 56) * (canvas.width/1280);
      const gapY = G.groundY() - h;
      obstacles.push({ x: G.worldW()+30, y: gapY, w, h, hit:false });
    }

    // ==== Game Over Screen (IMPLEMENTED) ====
    function showGameOver() {
      if (!overlay) return;
      overlay.style.display = 'grid';
      const panel = overlay.querySelector('.panel');
      if (!panel) return;
      panel.innerHTML = `
        <h2>게임 종료</h2>
        <p style="margin:6px 0 2px">점수: <strong>${G.score}</strong> · 최고점: <strong>${G.best}</strong></p>
        <div style="margin:12px 0 14px; opacity:.85">다시 도전해볼까요?</div>
        <div style="display:flex; gap:8px; justify-content:center">
          <button class="btn primary" id="restartBtn">다시 시작</button>
          <button class="btn ghost" id="shareBtn">점수 복사</button>
        </div>`;
      const restartBtn = panel.querySelector('#restartBtn');
      const shareBtn = panel.querySelector('#shareBtn');
      restartBtn?.addEventListener('click', () => { overlay.style.display='none'; startGame(); });
      shareBtn?.addEventListener('click', async () => {
        const txt = `Sky Runner 점수 ${G.score} (최고 ${G.best})`;
        try { await navigator.clipboard.writeText(txt); showToast('복사됨'); }
        catch { showToast('복사 실패'); }
      });
    }

    // ==== Start Screen (ensure visible on load) ====
    function showStartScreen(){
      if (!overlay) return;
      overlay.style.display = 'grid';
      const panel = overlay.querySelector('.panel');
      if (!panel) return;
      panel.innerHTML = `
        <h2>Tap · Click · Space 로 점프!</h2>
        <p>장애물을 피해 가능한 오래 달려보세요. 시간이 지날수록 속도가 증가합니다.</p>
        <div class="grid-keys" aria-hidden="true">
          <div class="key">스페이스</div>
          <div class="key">↑ / W</div>
          <div class="key">터치/클릭</div>
        </div>
        <button id="startBtn" class="btn primary" style="min-width:160px">게임 시작</button>
        <p style="margin-top:10px; font-size:13px; opacity:.8">모바일/PC 지원 · 로컬 저장소에 최고점/난이도 기록</p>`;
      panel.querySelector('#startBtn')?.addEventListener('click', () => { overlay.style.display='none'; ensureAudio(); startGame(); });
    }

    // ==== Inputs & Buttons (AFTER function declarations) ====
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); jump(); }
      else if (e.code === 'ArrowDown' || e.code === 'KeyS') { e.preventDefault(); fastDrop(); }
      else if (e.code === 'KeyP') { pauseToggle(); }
    });
    window.addEventListener('pointerdown', (e) => { if (e.button === 0) jump(); }, { passive: true });
    jumpBtn?.addEventListener('click', jump);
    pauseBtn?.addEventListener('click', pauseToggle);
    helpBtn?.addEventListener('click', () => { openHelpDialog(); });
    closeHelp?.addEventListener('click', () => helpDialog?.close());
    // 도움말 닫힘 시 자동 재개 (도움말이 만든 일시정지일 때만)
    helpDialog?.addEventListener('close', () => {
      if (helpPausedByDialog && G.running && G.paused && !G.over) {
        pauseToggle();
      }
      helpPausedByDialog = false;
    });
    resetBestBtn?.addEventListener('click', () => { localStorage.removeItem('sr_best'); G.best = 0; if (bestEl) bestEl.textContent = '0'; showToast('최고점 초기화됨'); });

    function startGame() { applyDifficulty(currentDiff); reset(); G.running = true; G.paused = false; rafStart(); }
    startBtn?.addEventListener('click', () => { if(overlay) overlay.style.display = 'none'; ensureAudio(); startGame(); });

    // ==== Start idle loop so canvas renders start screen ====
    rafStart();
    // ensure overlay is visible with start button, in case any style toggled previously
    showStartScreen();

    // ==== Tests (DO NOT change; only add) ====
    try {
      console.groupCollapsed('%cSkyRunner self-tests','color:#8cf');
      console.assert(typeof jump === 'function' && typeof pauseToggle === 'function', 'jump/pauseToggle should be defined before listeners');
      console.assert(typeof showGameOver === 'function', 'showGameOver should be defined');
      console.assert(typeof draw === 'function', 'draw should be defined');
      console.assert(typeof rectsIntersect === 'function', 'rectsIntersect should be defined');
      // draw should not throw
      try { draw(); console.log('draw() executed for smoke test'); } catch(e) { console.error(e); console.assert(false, 'draw should not throw'); }
      console.assert(!!canvas && !!ctx, 'Canvas/Context should exist');
      console.assert(!!scoreEl && !!bestEl, '#score/#best exist');
      const prev = G.speed; applyDifficulty('hard'); console.assert(G.speed !== prev, 'applyDifficulty should change speed'); applyDifficulty(currentDiff);
      setDiffUI(currentDiff); console.assert(diffLabel?.textContent, 'Diff label updated');
      console.assert(typeof rafStart === 'function' && typeof update === 'function', 'core loop functions exist');
      console.assert(typeof fastDrop === 'function', 'fastDrop should be defined');
      // 점프 체공시간(2*v0/g)이 난이도별 합리 범위인지 체크
      (function(){
        const ranges = { easy:[0.7,1.05], normal:[0.6,0.95], hard:[0.55,0.9], insane:[0.5,0.85] };
        const keep = currentDiff;
        for (const k of Object.keys(ranges)) {
          applyDifficulty(k); const at = 2*G.jumpV/G.gravity; const [lo,hi]=ranges[k];
          console.assert(at>=lo && at<=hi, `airtime for ${k}=${at.toFixed(2)}s inside [${lo},${hi}]`);
        }
        applyDifficulty(keep); setDiffUI(keep);
      })();
      // 스폰 간격 강제 테스트: 바로 앞에 장애물이 있으면 스폰 금지, 멀어지면 허용
      (function(){
        const keep = { t:G.t, last:G.lastSpawn };
        const baseLen = obstacles.length;
        obstacles.push({ x: canvas.width-40, y: G.groundY()-50, w:50, h:50, hit:false });
        G.t = G.lastSpawn + G.spawnEvery + 10;
        const blocked = trySpawnObstacle();
        console.assert(blocked===false && obstacles.length===baseLen+1, 'spawn blocked when gap small');
        obstacles[obstacles.length-1].x = 0;
        const allowed = trySpawnObstacle();
        console.assert(allowed===true && obstacles.length===baseLen+2, 'spawn allowed when gap satisfied');
        // cleanup
        obstacles.length = baseLen; G.t = keep.t; G.lastSpawn = keep.last;
      })();
      // overlay should be visible on load and have a start button
      console.assert(getComputedStyle(overlay).display !== 'none', 'overlay visible on load');
      console.assert(overlay.querySelector('#startBtn'), 'start button present on start screen');
      (function(){
        const prevDiff = currentDiff; const prevY = player.y; const prevOn = player.onGround;
        applyDifficulty('easy'); player.onGround=false; player.y = G.groundY()-player.h-50; fastDrop(); console.assert(player.onGround===true, 'fastDrop lands on easy');
        applyDifficulty('hard'); player.onGround=false; player.y = G.groundY()-player.h-50; const yBefore = player.y; fastDrop(); console.assert(player.onGround===false && player.y===yBefore, 'fastDrop disabled on hard');
        applyDifficulty(prevDiff); setDiffUI(prevDiff); player.y = prevY; player.onGround = prevOn;
      })();
      // 추가 테스트: 난이도 변경 시 재시작되고 점수/장애물이 초기화되는지, 도움말 클릭 시 일시정지되는지
      (function(){
        // 기존 테스트가 초기 화면 상태를 오염시키지 않도록 스냅샷 후 복구
        const snap = {
          running: G.running, paused: G.paused, over: G.over,
          diff: currentDiff, score: G.score, t: G.t, last: G.lastSpawn
        };
        const baseLen = obstacles.length;

        // 재시작 검증
        startGame();
        G.score = 5; obstacles.push({ x: 100, y: G.groundY()-50, w: 30, h: 40, hit:false });
        changeDifficultyAndRestart('easy');
        console.assert(G.running===true && G.score===0 && obstacles.length===0, 'difficulty change should restart & reset');

        // 도움말 일시정지 검증 + 닫을 때 재개, 스타트 화면에서는 자동시작 금지 검증
        if (helpDialog) {
          // in-game: open -> paused, close -> resume
          G.running = true; G.paused = false; openHelpDialog();
          console.assert(G.paused===true && helpDialog.open===true, 'help click pauses and opens dialog');
          helpDialog.close();
          console.assert(G.paused===false, 'closing help resumes game when auto-paused by help');

          // start-screen: open/close does not auto-start
          showStartScreen();
          G.running = false; G.paused = false; G.over = false;
          openHelpDialog();
          console.assert(helpDialog.open===true, 'help dialog opens on start screen');
          helpDialog.close();
          console.assert(G.running===false && getComputedStyle(overlay).display !== 'none', 'closing help on start screen must not auto-start');
        }

        // ===== 상태 복구: 초기 진입 시 스타트 화면이 떠야 함 =====
        applyDifficulty(snap.diff); setDiffUI(snap.diff);
        G.running = false; G.paused = false; G.over = false;
        G.score = 0; G.t = snap.t; G.lastSpawn = snap.last;
        obstacles.length = baseLen; particles.length = 0;
        if (overlay) { showStartScreen(); }
      })();
      console.log('All tests passed ✅');
      console.groupEnd();
    } catch (e) { console.error('Self-tests failed', e); }
  });
  </script>
</body>
</html>
